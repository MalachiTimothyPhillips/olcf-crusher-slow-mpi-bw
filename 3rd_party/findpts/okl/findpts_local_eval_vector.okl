// assumes p_blockSize >= p_Nq * p_Nq && p_blockSize >= 3*p_nptsBlock
@kernel void findpts_local_eval_vector(
        const dlong npts,
        const dlong inputOffset,
        const dlong outputOffset,
        @restrict const dlong *elIdx,
        @restrict const dfloat *rst,
        @restrict const dfloat *fld,
        @restrict dfloat *out)
{
  for (int fldIdx = 0; fldIdx < 3; fldIdx++; @outer(1)) {
  for (int pb = 0; pb < (npts+p_nptsBlock-1)/p_nptsBlock; pb++; @outer(0)) {
    @shared volatile dfloat s_L[p_nptsBlock][p_blockSize+1];
    @shared dfloat s_lj[p_nptsBlock][3][p_Nq];
    @shared dfloat s_rst[p_nptsBlock][3];

    for(int t = 0; t < p_blockSize ; ++t; @inner(0)) {
      const int l = t / p_Nq;
      const int m = t % p_Nq;

      if(t < 3*p_nptsBlock) {
        const int l = t / p_nptsBlock;
        const int m = t % p_nptsBlock;
        const int id = m + l*p_nptsBlock + pb*p_nptsBlock*3;
        if(id < 3*npts) s_rst[m][l] = rst[id];
      }
      @barrier("local"); // waiting for s_rst

      // compute Lagrangian basis in each direction
      #pragma unroll p_nptsBlock
      for (int i = 0; i < p_nptsBlock; i++) {
        if(i+pb*p_nptsBlock < npts && l < 3) {
          const dfloat r = s_rst[i][l];

          // 2^{p_Nq-1} factor accounts for product
          // of the inverses of the distances of the GLL points
          dfloat prod = (1 << (p_Nq-1));

          #pragma unroll p_Nq 
          for (int k = 0; k < p_Nq; k++) {
            prod *= k==m ? 1.0 : r - z[k];
          }
          s_lj[i][l][m] = prod * lagrangeCoeff[m]; 
        }
      }
    }

    @barrier("local");
    for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
      const int l = t / p_Nq;
      const int m = t % p_Nq;
      #pragma unroll p_nptsBlock 
      for (int i = 0; i < p_nptsBlock; i++) {
        if(i+pb*p_nptsBlock < npts) {
          const dfloat lj_lm = s_lj[i][1][l] * s_lj[i][0][m];
          const dlong iel = elIdx[i+pb*p_nptsBlock];
          dfloat sum = 0;
          #pragma unroll p_Nq 
          for (int k = 0; k < p_Nq; k++) {
            const int offset = iel*p_Np + k*p_Nq*p_Nq;
            sum += s_lj[i][2][k] * fld[m + l*p_Nq + offset + fldIdx * inputOffset]; 
          }
          s_L[i][m + l*p_Nq] = sum * lj_lm;
        }
      }
    }
    @barrier("local");

    for(int s = p_blockSize/2; s >=2; s >>= 1) {
      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if(t < s) {
          #pragma unroll
          for (int i = 0; i < p_nptsBlock; i++) {
            if(i+pb*p_nptsBlock < npts) s_L[i][t] += s_L[i][t+s];
          }
        }
      }
      @barrier("local");
    }

    // write out
    for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
      if(t < p_nptsBlock && t+pb*p_nptsBlock < npts) {
        out[t+pb*p_nptsBlock + fldIdx * outputOffset] = s_L[t][0] + s_L[t][1];
      }
    }
  }
  }
}