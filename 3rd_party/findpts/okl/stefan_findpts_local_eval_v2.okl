// assumes p_blockSize >= p_Nq * p_Nq && 3*p_nptsElementMax
@kernel void stefan_findpts_local_eval_v2(
        dfloat * const out_base,
        const dlong  * const el_base,
        const dfloat * const _r_base,
        const dlong nElements,
        const dlong * startPointIdx, const dlong * counts,
        @restrict const dfloat * const fld)
{
  for (int e = 0; e < nElements; e++; @outer(0)) { // loop over elements with particles
    const int iel = *(el_base + startPointIdx[e]);
    const int nptsElement = counts[e];

    const dfloat *const r_base = _r_base + 3*startPointIdx[e];
    const dfloat *flde = fld + iel*p_Np;
    dfloat *out = out_base + startPointIdx[e];

    @shared volatile dfloat s_L [p_nptsElementMax][p_blockSize];
    @shared dfloat s_lj[p_nptsElementMax][3*p_Nq];
    @shared dfloat s_rst[p_nptsElementMax][3];

    @exclusive dfloat f[p_Nq];

    for(int pt=0; pt < nptsElement; pt += p_nptsElementMax){
      for (int i = 0; i < p_nptsElementMax; i++) {
        for(int t = 0; t < p_blockSize ; ++t; @inner(0)) {
          if(t < p_Nq * p_Nq) {
            const int l = t / p_Nq;
            const int m = t % p_Nq;
            const int idp = i + pt;

            s_L[i][m + l*p_Nq] = 0; 

            // load rst coord of particle block into SMEM
            if(t < 3*p_nptsElementMax && i == 0) {
              const int l = t / p_nptsElementMax;
              const int m = t % p_nptsElementMax;
              const int id = m + (l+idp)*3;
              if(id < 3*nptsElement) s_rst[m][l] =  *(id + r_base);
            } 

            // load field data into GMEM
            if(idp == 0){
              #pragma unroll
              for(int k = 0; k < p_Nq; ++k)
                f[k] = flde[m + l*p_Nq + k*p_Nq*p_Nq]; 
            }

            if(idp < nptsElement) {
              // compute Lagrangian basis functions
              if (l == 0) {
                dfloat wrk[3] = {1, 1, 1};
                const dfloat r = s_rst[i][0];
                const dfloat s = s_rst[i][1];
                const dfloat t = s_rst[i][2];
                #pragma unroll
                for (int k = 0; k < p_Nq; k++) {      
                  const dfloat zk = z[k];
                  wrk[0] *= r - zk;
                  wrk[1] *= s - zk;
                  wrk[2] *= t - zk;
                }
                const dfloat wm = lagrangeCoeff[m];
                s_lj[i][m + 0*p_Nq] = wrk[0] * wm; 
                s_lj[i][m + 1*p_Nq] = wrk[1] * wm;
                s_lj[i][m + 2*p_Nq] = wrk[2] * wm;
              }
            }
          }
        }
        @barrier("local");
      }

      int i = 0;
      while(i < p_nptsElementMax && i+pt < nptsElement) {
        #pragma unroll
        for (int k = 0; k < p_Nq; k++) {
          for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
            if( t < p_Nq * p_Nq ) {
              const int l = t / p_Nq;
              const int m = t % p_Nq;
              s_L[i][m + l*p_Nq] += s_lj[i][k + 2*p_Nq] * 
                                    s_lj[i][l + 1*p_Nq] * 
                                    s_lj[i][m + 0*p_Nq] * 
                                    f[k]; 
            }
          }
          @barrier("local");
        }
        @barrier("local");
        i++;
      }

      for(int s = p_blockSize/2; s >=2; s >>= 1) {
        for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
          if(t < s) {
            #pragma unroll
            for (int i = 0; i < p_nptsElementMax; i++) {
              if(i+pt < nptsElement) s_L[i][t] += s_L[i][t+s];
            }
          }
        }
        @barrier("local");
      }

      // write out
      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if(t < p_nptsElementMax && t+pt < nptsElement)
          out[t+pt] = s_L[t][0] + s_L[t][1];
      }

    }
  }
}