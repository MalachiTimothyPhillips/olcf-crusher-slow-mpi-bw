// assumes p_blockSize >= p_Nq * p_Nq && 3*p_nptsElementMax
@kernel void stefan_findpts_local_eval_v2(
        dfloat * const out_base,
        const dlong  * const el_base,
        const dfloat * const _r_base,
        const dlong nElements,
        const dlong * startPointIdx, const dlong * counts,
        @restrict const dfloat * const fld)
{
  for (int e = 0; e < nElements; e++; @outer(0)) { // loop over elements with particles
    const int iel = *(el_base + startPointIdx[e]);
    const int nptsElement = counts[e];

    const dfloat *const r_base = _r_base + 3*startPointIdx[e];
    const dfloat *flde = fld + iel*p_Np;
    dfloat *out = out_base + startPointIdx[e];

    @shared volatile dfloat s_L [p_nptsElementMax][p_blockSize+1];
    @shared dfloat s_lj[p_nptsElementMax][3*p_Nq];
    @shared dfloat s_rst[p_nptsElementMax][3];

    @exclusive dfloat f[p_Nq];

    for(int pt=0; pt < nptsElement; pt += p_nptsElementMax){

      for(int t = 0; t < p_blockSize ; ++t; @inner(0)) {
        #pragma unroll
        for (int i = 0; i < p_nptsElementMax; i++) {
          const int idp = i + pt;
          if(t < 3*p_nptsElementMax && i == 0) {
            const int l = t / p_nptsElementMax;
            const int m = t % p_nptsElementMax;
            const int id = m + l*p_nptsElementMax + idp*3;
            if(id < 3*nptsElement) s_rst[m][l] =  *(id + r_base);
          }

          if(t < p_Nq * p_Nq) {
            const int l = t / p_Nq;
            const int m = t % p_Nq;

            // load field data into GMEM
            if(idp == 0){
              #pragma unroll
              for(int k = 0; k < p_Nq; ++k)
                f[k] = flde[m + l*p_Nq + k*p_Nq*p_Nq]; 
            }

            s_L[i][m + l*p_Nq] = 0; 

            @barrier("local");
            if(idp < nptsElement) {
              // compute Lagrangian basis functions
              if (l < 3) {
                dfloat wrk = 1;
                const dfloat r = s_rst[i][l];
                #pragma unroll
                for (int k = 0; k < p_Nq; k++) {      
                  const dfloat zk = z[k];
                  wrk *= r - zk;
                }

                const dfloat wm = lagrangeCoeff[m];
                s_lj[i][m + l*p_Nq] = wrk * wm; 
              }
            }
          }
        }
      }
      @barrier("local");

      for (int i = 0; i < p_nptsElementMax; i++) {
        if(i+pt < nptsElement) {
          for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
            if(t < p_Nq * p_Nq) {
              const int l = t / p_Nq;
              const int m = t % p_Nq;
              dfloat sum = 0;
              #pragma unroll
              for (int k = 0; k < p_Nq; k++) {
                sum += s_lj[i][k + 2*p_Nq] * f[k]; 
              }
              s_L[i][m + l*p_Nq] = sum * s_lj[i][l + 1*p_Nq] * s_lj[i][m + 0*p_Nq];
            }
          }
        }
      }
      @barrier("local");

      for(int s = p_blockSize/2; s >=2; s >>= 1) {
        for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
          if(t < s) {
            #pragma unroll
            for (int i = 0; i < p_nptsElementMax; i++) {
              if(i+pt < nptsElement) s_L[i][t] += s_L[i][t+s];
            }
          }
        }
        @barrier("local");
      }

      // write out
      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if(t < p_nptsElementMax && t+pt < nptsElement)
          out[t+pt] = s_L[t][0] + s_L[t][1];
      }

    }
  }
}
