// assumes p_blockSize >= p_Nq * p_Nq && p_blockSize >= 3*p_nptsBlock
@kernel void findpts_local_eval_many(const dlong npts,
                                     const dlong nFields,
                                     const dlong inputOffset,
                                     const dlong outputOffset,
                                     @ restrict const dlong *elIdx,
                                     @ restrict const dfloat *rst,
                                     @ restrict const dfloat *fld,
                                     @ restrict dfloat *out)
{
  for (int fldIdx = 0; fldIdx < nFields; fldIdx++; @outer(1)) {
    for (int pb = 0; pb < (npts + p_nptsBlock - 1) / p_nptsBlock; pb++; @outer(0)) {
      @shared volatile dfloat s_L[p_nptsBlock][p_blockSize + 1];
      @shared dfloat s_lj[p_nptsBlock][3][p_Nq];
      @shared dfloat s_rst[p_nptsBlock][3];

      for (int t = 0; t < p_blockSize; ++t; @inner(0)) {
        const int l = t / p_Nq;
        const int m = t % p_Nq;

        if (t < 3 * p_nptsBlock) {
          const int l = t / p_nptsBlock;
          const int m = t % p_nptsBlock;
          const int id = m + l * p_nptsBlock + pb * p_nptsBlock * 3;
          if (id < 3 * npts)
            s_rst[m][l] = rst[id];
        }
        @barrier("local"); // waiting for s_rst

// compute Lagrangian basis in each direction
#pragma unroll p_nptsBlock
        for (int i = 0; i < p_nptsBlock; i++) {
          if (i + pb * p_nptsBlock < npts && l < 3) {
            const dfloat r = s_rst[i][l];

            // 2^{p_Nq-1} factor accounts for product
            // of the inverses of the distances of the GLL points
            dfloat prod = (1 << (p_Nq - 1));

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              prod *= k == m ? 1.0 : r - z[k];
            }
            s_lj[i][l][m] = prod * lagrangeCoeff[m];
          }
        }
      }

      @barrier("local");
      for (int t = 0; t < p_blockSize; ++t; @inner(0)) {
        const int l = t / p_Nq;
        const int m = t % p_Nq;
#pragma unroll p_nptsBlock
        for (int i = 0; i < p_nptsBlock; i++) {
          if (i + pb * p_nptsBlock < npts) {
            const dfloat lj_lm = s_lj[i][1][l] * s_lj[i][0][m];
            const dlong iel = elIdx[i + pb * p_nptsBlock];
            dfloat sum = 0;
#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              const int offset = iel * p_Np + k * p_Nq * p_Nq;
              sum += s_lj[i][2][k] * fld[m + l * p_Nq + offset + fldIdx * inputOffset];
            }
            s_L[i][m + l * p_Nq] = sum * lj_lm;
          }
        }
      }
      @barrier("local");

      for (int s = p_blockSize / 2; s >= 2; s >>= 1) {
        for (int t = 0; t < p_blockSize; ++t; @inner(0)) {
          if (t < s) {
#pragma unroll
            for (int i = 0; i < p_nptsBlock; i++) {
              if (i + pb * p_nptsBlock < npts)
                s_L[i][t] += s_L[i][t + s];
            }
          }
        }
        @barrier("local");
      }

      // write out
      for (int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if (t < p_nptsBlock && t + pb * p_nptsBlock < npts) {
          out[t + pb * p_nptsBlock + fldIdx * outputOffset] = s_L[t][0] + s_L[t][1];
        }
      }
    }
  }
}