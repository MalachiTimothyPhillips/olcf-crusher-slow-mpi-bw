// assumes p_blockSize >= p_Nq * p_Nq && 3*p_nptsElementMax
@kernel void stefan_findpts_local_eval_v3(
        dfloat * const out_base,
        const dlong  * const el_base,
        const dfloat * const _r_base,
        const dlong nElements,
        const dlong * startPointIdx, const dlong * counts,
        @restrict const dfloat * const fld)
{
  for (int e = 0; e < nElements; e++; @outer(0)) { // loop over elements with particles
    const int iel = *(el_base + startPointIdx[e]);
    const int nptsElement = counts[e];

    const dfloat *const r_base = _r_base + 3*startPointIdx[e];
    const dfloat *flde = fld + iel*p_Np;
    dfloat *out = out_base + startPointIdx[e];

    @shared dfloat wtr[p_nptsElementMax][p_Nq];
    @shared dfloat wts[p_nptsElementMax][p_Nq];
    @shared dfloat wtt[p_nptsElementMax][p_Nq];

    @shared dfloat sums[p_nptsElementMax][p_Nq];

    //@exclusive dfloat f[p_Nq];
    // need to figure out a better way to do this...
    @shared dfloat s_fld[p_Nq][p_Nq][p_Nq];

    for(int pt=0; pt < nptsElement; pt += p_nptsElementMax){
      for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
        for(int j = 0; j < p_Nq ; ++j; @inner(0)) {
          sums[i][j] = 0.0;
          const dlong pid = i + pt;
          if(pid < nptsElement) {
            const dfloat * r = r_base + 3 * pid;
            lagrange_eval(&(wtr[i][0]), r[0], j);
            lagrange_eval(&(wts[i][0]), r[1], j);
            lagrange_eval(&(wtt[i][0]), r[2], j);
          }
          if(pt == 0 && i == 0){
            #pragma unroll
            for(int k = 0; k < p_Nq; ++k){
              #pragma unroll
              for(int l = 0; l < p_Nq; ++l){
                s_fld[j][k][l] = flde[l + k * p_Nq + j * p_Nq * p_Nq];
              }
            }
          }
        }
      }
      @barrier("local");
      for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
        for (dlong j=0;j<p_Nq;++j;@inner(0)){
          const dlong pid = i + pt;
          if(pid < nptsElement) {
            dfloat sum_j = 0;
            #pragma unroll
            for(dlong k=0;k<p_Nq;++k){
              dfloat sum_k = 0;

              #pragma unroll
              for(dlong l=0;l<p_Nq;++l){
                sum_k += s_fld[j][k][l] * wtt[i][l];
              }
              sum_j += wts[i][k]*sum_k;
            }
            sums[i][j] = wtr[i][j]*sum_j;
          }
        }
      }
#if p_Nq>16
    for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
    for(dlong j=0;j<p_Nq;++j;@inner(0)){
      if(j<16&&j<p_Nq-16){
        sums[i][j] += sums[i][j+16];
      }
    }
    }
    @barrier("local");
#endif
#if p_Nq>8
    for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
    for(dlong j=0;j<p_Nq;++j;@inner(0)){
      if(j<8&&j<p_Nq-8){
        sums[i][j] += sums[i][j+8];
      }
    }
    }
    @barrier("local");
#endif
#if p_Nq>4
    for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
    for(dlong j=0;j<p_Nq;++j;@inner(0)){
      if(j<4&&j<p_Nq-4){
        sums[i][j] += sums[i][j+4];
      }
    }
    }
    @barrier("local");
#endif
#if p_Nq>2
    for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
    for(dlong j=0;j<p_Nq;++j;@inner(0)){
      if(j<2&&j<p_Nq-2){
        sums[i][j] += sums[i][j+2];
      }
    }
    }
    @barrier("local");
#endif
    for (int i = 0; i < p_nptsElementMax; i++; @inner(1)) {
    for(dlong j=0;j<p_Nq;++j;@inner(0)){
      if(j==0){
        const dlong pid = i + pt;
        if(pid < nptsElement){
          out[pid] = sums[i][0] + sums[i][1];
        }
      }
    }
    }
    @barrier("local");
      }
  }
}