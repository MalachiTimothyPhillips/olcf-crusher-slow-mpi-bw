// assumes p_blockSize >= p_Nq * p_Nq && 3*p_nptsElementMax
@kernel void findpts_local_eval(
        const dlong npts,
        @restrict const dlong *elIdx,
        @restrict const dfloat *rst,
        @restrict const dfloat *fld,
        @restrict dfloat *out)
{
  for (int pb = 0; pb < (npts+p_nptsBlock-1)/p_nptsBlock; pb++; @outer(0)) {
    @shared volatile dfloat s_L[p_nptsBlock][p_blockSize+1];
    @shared dfloat s_lj[p_nptsBlock][3][p_Nq];
    @shared dfloat s_rst[p_nptsBlock][3];

    for(int t = 0; t < p_blockSize ; ++t; @inner(0)) {
      const int l = t / p_Nq;
      const int m = t % p_Nq;

      if(t < 3*p_nptsBlock) {
        const int l = t / p_nptsBlock;
        const int m = t % p_nptsBlock;
        const int id = m + l*p_nptsBlock + pb*p_nptsBlock*3;
        if(id < 3*npts) s_rst[m][l] = rst[id];
      }
      @barrier("local"); // waiting for s_rst

      // compute Lagrangian basis in each direction
      #pragma unroll p_nptsBlock
      for (int i = 0; i < p_nptsBlock; i++) {
        if(i+pb*p_nptsBlock < npts && l < 3) {
          const dfloat r = s_rst[i][l];
          dfloat prod = (1 << (p_Nq-1));

          #pragma unroll p_Nq 
          for (int k = 0; k < p_Nq; k++) {
            prod *= k==m ? 1.0 : r - z[k];
          }
          s_lj[i][l][m] = prod * lagrangeCoeff[m]; 
        }
      }
    }

    @barrier("local");
    for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
      const int l = t / p_Nq;
      const int m = t % p_Nq;
      #pragma unroll p_nptsBlock 
      for (int i = 0; i < p_nptsBlock; i++) {
        if(i+pb*p_nptsBlock < npts) {
          const dfloat lj_lm = s_lj[i][1][l] * s_lj[i][0][m];
          const dlong iel = elIdx[i+pb*p_nptsBlock];
          dfloat sum = 0;
          #pragma unroll p_Nq 
          for (int k = 0; k < p_Nq; k++) {
            const int offset = iel*p_Np + k*p_Nq*p_Nq;
            sum += s_lj[i][2][k] * fld[m + l*p_Nq + offset]; 
          }
          s_L[i][m + l*p_Nq] = sum * lj_lm;
        }
      }
    }
    @barrier("local");

    for(int s = p_blockSize/2; s >=2; s >>= 1) {
      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if(t < s) {
          #pragma unroll
          for (int i = 0; i < p_nptsBlock; i++) {
            if(i+pb*p_nptsBlock < npts) s_L[i][t] += s_L[i][t+s];
          }
        }
      }
      @barrier("local");
    }

    // write out
    for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
      if(t < p_nptsBlock && t+pb*p_nptsBlock < npts) {
        out[t+pb*p_nptsBlock] = s_L[t][0] + s_L[t][1];
      }
    }
  }
}

#if 0
@kernel void findpts_local_eval_eBlock(
        dfloat * const out_base,
        const dlong  * const el_base,
        const dfloat * const _r_base,
        const dlong nElements,
        const dlong * startPointIdx, const dlong * counts,
        @restrict const dfloat * const fld)
{
  for (int e = 0; e < nElements; e++; @outer(0)) { // loop over elements with particles
    const int iel = *(el_base + startPointIdx[e]);
    const int nptsElement = counts[e];

    const dfloat *const r_base = _r_base + 3*startPointIdx[e];
    const dfloat *fld_e = fld + iel*p_Np;
    dfloat *out = out_base + startPointIdx[e];

    @shared volatile dfloat s_L[p_nptsElementMax][p_blockSize+1];
    @shared dfloat s_lj[p_nptsElementMax][3][p_Nq];
    @shared dfloat s_rst[p_nptsElementMax][3];

    @exclusive dfloat f[p_Nq];

    for(int pt=0; pt < nptsElement; pt += p_nptsElementMax){

      for(int t = 0; t < p_blockSize ; ++t; @inner(0)) {
        const int l = t / p_Nq;
        const int m = t % p_Nq;

        if(t < 3*p_nptsElementMax) {
          const int l = t / p_nptsElementMax;
          const int m = t % p_nptsElementMax;
          const int id = m + l*p_nptsElementMax + pt*3;
          if(id < 3*nptsElement) s_rst[m][l] =  *(id + r_base);
        }

        if(pt == 0) {
          #pragma unroll
          for(int k = 0; k < p_Nq; ++k)
            f[k] = fld_e[m + l*p_Nq + k*p_Nq*p_Nq]; 
        }

        @barrier("local"); // waiting for s_rst
        #pragma unroll
        for (int i = 0; i < p_nptsElementMax; i++) {
          // compute Lagrangian basis in each direction
          if(i+pt < nptsElement && l < 3) {
            const dfloat r = s_rst[i][l];
            dfloat prod = 1;
            #pragma unroll
            for (int k = 0; k < p_Nq; k++)
              prod *= r - z[k];

            s_lj[i][l][m] = prod * lagrangeCoeff[m]; 
          }
        }
      }
      @barrier("local");

      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        const int l = t / p_Nq;
        const int m = t % p_Nq;
        #pragma unroll
        for (int i = 0; i < p_nptsElementMax; i++) {
          if(i+pt < nptsElement) {
            const dfloat lj_lm = s_lj[i][1][l] * s_lj[i][0][m];
            dfloat sum = 0;
            #pragma unroll
            for (int k = 0; k < p_Nq; k++) {
              sum += s_lj[i][2][k] * f[k]; 
            }
            s_L[i][m + l*p_Nq] = sum * lj_lm;
          }
        }
      }
      @barrier("local");

      for(int s = p_blockSize/2; s >=2; s >>= 1) {
        for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
          if(t < s) {
            #pragma unroll
            for (int i = 0; i < p_nptsElementMax; i++) {
              if(i+pt < nptsElement) s_L[i][t] += s_L[i][t+s];
            }
          }
        }
        @barrier("local");
      }

      // write out
      for(int t = 0; t < p_blockSize; ++t; @inner(0)) {
        if(t < p_nptsElementMax && t+pt < nptsElement)
          out[t+pt] = s_L[t][0] + s_L[t][1];
      }

    }
  }
}
#endif
