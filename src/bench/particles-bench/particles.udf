#include <math.h>
#include <numeric>
#include "udf.hpp"
#include "plugins/particle.hpp"
#include <omp.h>

#include <vector>
#include <array>
#include <algorithm>

/* UDF Functions */                                                      
static int nParticles;
static lpm_t *particles;

occa::kernel applyPeriodicityKernel;

enum class BENCHMARK{
  ALL, // mode 0
  FINDPTS_LOCAL, // mode 1
  FINDPTS_LOCAL_EVAL, // mode 2
  PARTICLE_UPDATE, // mode 3
  INVALID,
};

BENCHMARK benchmarkMode;

BENCHMARK ciModeToBenchmark(dlong mode)
{
  if(mode == 0){
    return BENCHMARK::ALL;
  }
  if(mode == 1){
    return BENCHMARK::FINDPTS_LOCAL;
  }
  if(mode == 2){
    return BENCHMARK::FINDPTS_LOCAL_EVAL;
  }
  if(mode == 3){
    return BENCHMARK::PARTICLE_UPDATE;
  }

  return BENCHMARK::INVALID;
}


/* Particle Functions */
void particleInit(lpm_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // evenly distribute cubrt(nParticles)^3 particles in [0,1]^3

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
          particle_t particle;

          particle.x = xp;
          particle.y = yp;
          particle.z = zp;
          particle.id = gcount;
          p.push(particle);
        }
        ++gcount; // Total count
      }
    }
  }
}

// apply periodicity for particles on [0,1]^3
void applyBounds(lpm_t& p) {
  applyPeriodicityKernel(p.size(),
    p.device_x(),
    p.device_y(),
    p.device_z());
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  applyPeriodicityKernel = oudfBuildKernel(kernelInfo, "applyPeriodicity");
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  platform->par->extract("casedata", "p_nparticles", nParticles);

  int ciMode;
  options.getArgs("CI-MODE", ciMode);
  benchmarkMode = ciModeToBenchmark(ciMode);

  if(benchmarkMode == BENCHMARK::INVALID){
    printf("Invalid benchmark mode specified!\n");
    ABORT(1);
  }
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new lpm_t(nrs, 0);
}

double run_particle_update(nrs_t* nrs, lpm_t& particles, int Ntrials, std::array<dfloat, 3>& dt)
{
  platform->device.finish();
  MPI_Barrier(platform->comm.mpiComm);
  const double start = MPI_Wtime();

  for(int tstep = 1; tstep <= Ntrials; ++tstep){
    particles.update(nrs->o_U, dt.data(), tstep);
    applyBounds(particles);
  }

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  return (MPI_Wtime() - start) / Ntrials;
}

double run_findpts_local_bench(nrs_t* nrs, lpm_t& particles, int Ntrials)
{
  const auto pn = particles.size();

  std::vector<dfloat> x(pn, 0.0);
  std::vector<dfloat> y(pn, 0.0);
  std::vector<dfloat> z(pn, 0.0);

  for(int p = 0; p < particles.size(); ++p){
    x[p] = particles.x(p);
    y[p] = particles.y(p);
    z[p] = particles.z(p);
  }

  findpts_data_t data(pn);

  auto findpts = particles.interp().ptr();

  occa::memory  d_code_base = platform->device.malloc(  sizeof(dlong) *pn);
  occa::memory    d_el_base = platform->device.malloc(  sizeof(dlong) *pn);
  occa::memory     d_r_base = platform->device.malloc(3*sizeof(dfloat)*pn);
  occa::memory d_dist2_base = platform->device.malloc(  sizeof(dfloat)*pn);
  occa::memory     d_x_base = platform->device.malloc(3*sizeof(dfloat*)  );
  occa::memory    d_x0_base = platform->device.malloc( sizeof(dfloat)*pn);
  occa::memory    d_x1_base = platform->device.malloc( sizeof(dfloat)*pn);
  occa::memory    d_x2_base = platform->device.malloc( sizeof(dfloat)*pn);

  dfloat *x_base_d[3] = {(double*)d_x0_base.ptr(), (double*)d_x1_base.ptr(), (double*)d_x2_base.ptr()};
  d_x_base.copyFrom(x_base_d, 3*sizeof(dfloat*));
  d_x0_base.copyFrom(x.data(), sizeof(dfloat)*pn);
  d_x1_base.copyFrom(y.data(), sizeof(dfloat)*pn);
  d_x2_base.copyFrom(z.data(), sizeof(dfloat)*pn);

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto start = MPI_Wtime();
  {
    for(int i = 0; i < Ntrials; ++i){
      findpts->local_kernel( d_code_base,
                              d_el_base, 
                               d_r_base, 
                           d_dist2_base, 
                               d_x_base, 
                           pn, findpts->o_fd_local);
    }
  }
  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto end = MPI_Wtime();

  d_code_base.free();
  d_el_base.free();
  d_r_base.free();
  d_dist2_base.free();
  d_x_base.free();
  d_x0_base.free();
  d_x1_base.free();
  d_x2_base.free();

  return (end - start) / Ntrials;
}

double run_findpts_local_eval_bench(nrs_t* nrs, lpm_t& particles, int Ntrials)
{

  // sort particle entries by element
  particles.sort();

  auto* mesh = nrs->meshV;

  const auto Np = nrs->meshV->Np;

  const auto pn = particles.size();

  std::vector<dfloat> r(3*pn, 0.0);
  std::vector<dlong> code(pn, 0);
  std::vector<dlong> proc(pn, 0);
  std::vector<dlong> el(pn, 0);
  std::vector<dlong> eltmp(pn, 0); // for std::unique

  bool sorted = true;

  auto prev = particles[0].el;

  for(int p = 0; p < pn; ++p){
    auto particle = particles[p];
    code[p] = particle.code;
    proc[p] = particle.proc;
    el[p] = particle.el;
    eltmp[p] = particle.el;
    r[3*p + 0] = particle.r;
    r[3*p + 1] = particle.s;
    r[3*p + 2] = particle.t;

    auto currElem = particle.el;
    sorted&= prev <= currElem;
    prev = currElem;
  }

  if(!sorted){
    std::cout << "Not sorted! Bailing!\n";
    ABORT(1);
  }

  auto last = std::unique(eltmp.begin(), eltmp.end());
  eltmp.erase(last, eltmp.end());

  const auto NelemP = eltmp.size();

  std::vector<dlong> particlesInElem(NelemP, 0);
  int index = 0;
  auto lastElem = eltmp[0];
  for(int p = 0; p < pn; ++p){
    auto elem = el[p];
    if(lastElem != elem){
      lastElem = elem;
      index++;
    }
    if(index >= NelemP){
      std::cout << "Index too large! Failing\n";
      ABORT(1);
    }
    particlesInElem[index] += 1;
  }

  if(index!= (NelemP - 1)){
    std::cout << "Index is incorrect! Failing\n";
    ABORT(1);
  }

  // sanity check: sum of particlesInElem must match number particles
  int sumP = 0;
  for(auto&& count : particlesInElem){
    sumP += count;
  }

  if(sumP != pn){
    std::cout << "Different number of particles than expected!\n";
    ABORT(1);
  }

  std::vector<dlong> startPointIdx(NelemP, 0);
  startPointIdx[0] = 0;
  for(int el = 1; el < NelemP; ++el){
    startPointIdx[el] = startPointIdx[el-1] + particlesInElem[el-1];
  }

  occa::memory o_starts = platform->device.malloc(NelemP * sizeof(dlong));
  occa::memory o_counts = platform->device.malloc(NelemP * sizeof(dlong));

  o_starts.copyFrom(startPointIdx.data(), NelemP * sizeof(dlong));
  o_counts.copyFrom(particlesInElem.data(), NelemP * sizeof(dlong));

  constexpr int nFields = 3;

  occa::memory o_out = platform->device.malloc(nFields * pn * sizeof(dfloat));
  occa::memory o_r   = platform->device.malloc(3 * pn * sizeof(dfloat));
  occa::memory o_el =  platform->device.malloc(pn * sizeof(dlong));

  o_r.copyFrom(r.data(), 3 * pn * sizeof(dfloat));
  o_el.copyFrom(el.data(), pn * sizeof(dlong));

  auto o_Ux = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
  auto o_Uy = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
  auto o_Uz = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

  const double Ux = 1.5;
  const double Uy = 2.5;
  const double Uz = 3.5;

  platform->linAlg->fill(mesh->Nlocal, Ux, o_Ux);
  platform->linAlg->fill(mesh->Nlocal, Uy, o_Uy);
  platform->linAlg->fill(mesh->Nlocal, Uz, o_Uz);

  auto o_outx = o_out + 0 * pn * sizeof(dfloat);
  auto o_outy = o_out + 1 * pn * sizeof(dfloat);
  auto o_outz = o_out + 2 * pn * sizeof(dfloat);

  auto o_out_expected = platform->device.malloc(3*pn, sizeof(dfloat));
  auto o_outx_expected = o_out_expected + 0 * pn * sizeof(dfloat);
  auto o_outy_expected = o_out_expected + 1 * pn * sizeof(dfloat);
  auto o_outz_expected = o_out_expected + 2 * pn * sizeof(dfloat);

  platform->linAlg->fill(pn, Ux, o_outx_expected);
  platform->linAlg->fill(pn, Uy, o_outy_expected);
  platform->linAlg->fill(pn, Uz, o_outz_expected);

  auto* findpts = particles.interp().ptr();

  // correctness check
  findpts->local_eval_many_kernel(pn, 3, nrs->fieldOffset, pn, o_el, o_r, nrs->o_U, o_out);

  platform->linAlg->axpbyMany(
    pn,
    3,
    pn,
    1.0,
    o_out_expected,
    -1.0,
    o_out
  );

  const auto error = platform->linAlg->norm2Many(
    pn,
    3,
    pn,
    o_out,
    platform->comm.mpiComm
  );

  if(platform->comm.mpiRank == 0){
    std::cout << "Error in findpts_local_eval kernel: " << error << std::endl;
  }

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto start = MPI_Wtime();
  {
    for(int i = 0; i < Ntrials; ++i){
      findpts->local_eval_many_kernel(pn, 3, nrs->fieldOffset, pn, o_el, o_r, nrs->o_U, o_out);
    }
  }
  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);

  const auto end = MPI_Wtime();

  o_out.free();
  o_r.free();
  o_el.free();

  return (end - start) / Ntrials;
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat /** unused **/, int /** unused **/)
{
  auto * mesh = nrs->meshV;

  particleInit  (*particles);

  // required to apply periodic applyBounds
  particles->addPostIntegrationWork(applyBounds);

  if(benchmarkMode == BENCHMARK::PARTICLE_UPDATE || benchmarkMode == BENCHMARK::ALL)
  {
    int Nstep = 10;
    std::array<dfloat, 3> dt = {1.0 / Nstep, 1.0 / Nstep, 1.0 / Nstep};

    auto o_U_x = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
    auto o_U_y = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
    auto o_U_z = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

    platform->linAlg->fill(mesh->Nlocal, 1.0, o_U_x);
    platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_y);
    platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_z);

    // will integrate for 1 time unit -- puts particles back at original location
    double elapsed = run_particle_update(nrs, *particles, 10, dt);

    int nParticleDir = std::round(std::cbrt(nParticles));
    nParticles = nParticleDir * nParticleDir * nParticleDir;

    std::vector<dfloat> expectedX(nParticles, 0.0);
    std::vector<dfloat> expectedY(nParticles, 0.0);
    std::vector<dfloat> expectedZ(nParticles, 0.0);
    std::vector<dlong> particleIds(nParticles, 0);
  
    const dfloat Lx = 1.0;
    const dfloat Ly = 1.0;
    const dfloat Lz = 1.0;

    const dfloat invNParticleDir = 1.0 / nParticleDir;

    dlong particleCtr = 0.0;
    for (int ix = 0; ix < nParticleDir; ++ix) {
      for (int iy = 0; iy < nParticleDir; ++iy) {
        for (int iz = 0; iz < nParticleDir; ++iz) {

          dfloat dx = Lx * invNParticleDir;
          dfloat dy = Ly * invNParticleDir;
          dfloat dz = Lz * invNParticleDir;

          dfloat xp = dx*(ix+0.5);
          dfloat yp = dy*(iy+0.5);
          dfloat zp = dz*(iz+0.5);

          expectedX[particleCtr] = xp;
          expectedY[particleCtr] = yp;
          expectedZ[particleCtr] = zp;
          particleIds[particleCtr] = particleCtr;
          particleCtr++;
        }
      }
    }

    dfloat errPos = 0.0;

    for(int i = 0; i < particles->size(); ++i){
      // find "global" index of particle to get expected coordinate
      auto found = std::lower_bound(particleIds.begin(), particleIds.end(), particles->particleIndex(i));
      auto globalIndex = *found;
      errPos += std::abs(particles->x(i) - expectedX[globalIndex]);
      errPos += std::abs(particles->y(i) - expectedY[globalIndex]);
      errPos += std::abs(particles->z(i) - expectedZ[globalIndex]);
    }

    MPI_Allreduce(MPI_IN_PLACE, &errPos, 1, MPI_DFLOAT, MPI_SUM, platform->comm.mpiComm);

    errPos /= nParticles;

    if(platform->comm.mpiRank == 0){
      std::cout << "\nError in position: " << errPos << "\n\n";
    }

    const dfloat testTol = 1e-12;

    if(errPos > testTol){
      if(platform->comm.mpiRank == 0){
        std::cout << "Error too large. Failing test!\n";
      }
      MPI_Finalize();
      exit(2);
    }

    // done with correctness check...

    // Now the benchmark:
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;

    elapsed = run_particle_update(nrs, *particles, Ntests, dt);

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "particle update:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
    }

    const double tUpdate      = platform->timer.query("lpm_t::update", "DEVICE:MAX");
    const double tFind        = platform->timer.query("lpm_t::find", "DEVICE:MAX");
    const double tMigrate     = platform->timer.query("lpm_t::migrate", "DEVICE:MAX");
    const double tInterpLocal = platform->timer.query("lpm_t::interpLocal", "DEVICE:MAX");
    const double tAdvance     = platform->timer.query("lpm_t::advance", "DEVICE:MAX");
    const double tSync        = platform->timer.query("lpm_t::syncToDevice", "DEVICE:MAX");
    const double tPostIntegrationWork = platform->timer.query("lpm_t::advance::postIntegrationWork", "DEVICE:MAX");
    const double tCopyBackToHost = platform->timer.query("lpm_t::advance::copyBackToHost", "DEVICE:MAX");
    std::cout <<   "lpm_t::update                            " << tUpdate << "s\n";
    std::cout <<   "  lpm_t::find                            " << tFind << "s\n";
    std::cout <<   "  lpm_t::migrate                         " << tMigrate << "s\n";
    std::cout <<   "  lpm_t::interpLocal                     " << tInterpLocal << "s\n";
    std::cout <<   "  lpm_t::advance                         " << tAdvance << "s\n";
    std::cout <<   "    lpm_t::advance::postIntegrationWork  " << tPostIntegrationWork << "s\n";
    std::cout <<   "    lpm_t::advance::copyBackToHost       " << tCopyBackToHost << "s\n";
    std::cout <<   "  lpm_t::syncToDevice     " << tSync << "s\n";
    std::cout << std::endl;

  }

  if(benchmarkMode == BENCHMARK::FINDPTS_LOCAL || benchmarkMode == BENCHMARK::ALL)
  {
    double elapsed = run_findpts_local_bench(nrs, *particles, 10);
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;
    elapsed = run_findpts_local_bench(nrs, *particles, Ntests);

    const auto nParticles = particles->size();

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "findpts_local kernel:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
      std::cout << std::endl;
    }

  }

  if(benchmarkMode == BENCHMARK::FINDPTS_LOCAL_EVAL || benchmarkMode == BENCHMARK::ALL)
  {
    // set up data for findpts_local_eval call
    std::array<dfloat, 3> dt = {0.1, 0.1, 0.1};
    particles->update(nrs->o_U, dt.data(), 1);

    double elapsed = run_findpts_local_eval_bench(nrs, *particles, 10);
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;
    elapsed = run_findpts_local_eval_bench(nrs, *particles, Ntests);

    const auto nParticles = particles->size();

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "findpts_local_eval kernel:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
    }

  }

  EXIT_AND_FINALIZE(0);
}
