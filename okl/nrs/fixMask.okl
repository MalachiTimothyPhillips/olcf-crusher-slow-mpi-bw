void crossProduct(const dfloat a[3], const dfloat b[3], dfloat c[3])
{
  c[0] = a[1] * b[2] - a[2] * b[1];
  c[1] = a[2] * b[0] - a[0] * b[2];
  c[2] = a[0] * b[1] - a[1] * b[0];

  const dfloat mag = sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
  const dfloat invMag = 1.0 / mag;
  c[0] *= invMag;
  c[1] *= invMag;
  c[2] *= invMag;
}

dfloat dot(const dfloat a[3], const dfloat b[3])
{
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

// Shared element edge of type p_ZERO_NORMAL is not supported.
@kernel void fixMask(const dlong Nelements,
                                         const dlong offset,
                                         @restrict dfloat*  sgeo,
                                         @restrict const dlong*  vmapM,
                                         @restrict const int*  EToB,
                                         @restrict const dfloat*  normal,
                                         @restrict dfloat* mask)
{
  for(dlong e = 0; e < Nelements; e++; @outer(0)) {

    for(int f = 0; f < p_Nfaces; f++) {
      for(int m = 0; m < p_Nfp; ++m; @inner(0)) {
        const int n = m + f * p_Nfp;
        const int sk = e * p_Nfp * p_Nfaces + n;
        const dlong sid  = e * p_Nfaces * p_Nfp + n;
        const dlong idM = vmapM[sk];
        const dlong bcType = EToB[f + p_Nfaces * e];

        if(bcType == p_ZERO_NORMAL) {

          const dfloat nx = sgeo[sid * p_Nsgeo + p_NXID];
          const dfloat ny = sgeo[sid * p_Nsgeo + p_NYID];
          const dfloat nz = sgeo[sid * p_Nsgeo + p_NZID];
          dfloat volNx = normal[idM + 0 * offset];
          dfloat volNy = normal[idM + 1 * offset];
          dfloat volNz = normal[idM + 2 * offset];
          dfloat count = normal[idM + 3 * offset];

          const dfloat invCount = 1.0 / count;
          volNx *= invCount;
          volNy *= invCount;
          volNz *= invCount;

          const dfloat volNMag = sqrt(volNx * volNx + volNy * volNy + volNz * volNz);

          const dfloat tol = 1e-6;
          if(abs(1.0-volNMag) > tol) {

            const dfloat invVolNMag = 1.0 / volNMag;
            volNx *= invVolNMag;
            volNy *= invVolNMag;
            volNz *= invVolNMag;

            const dfloat t1x = sgeo[sid * p_Nsgeo + p_T1XID];
            const dfloat t1y = sgeo[sid * p_Nsgeo + p_T1YID];
            const dfloat t1z = sgeo[sid * p_Nsgeo + p_T1ZID];

            const dfloat t2x = sgeo[sid * p_Nsgeo + p_T2XID];
            const dfloat t2y = sgeo[sid * p_Nsgeo + p_T2YID];
            const dfloat t2z = sgeo[sid * p_Nsgeo + p_T2ZID];

            const dfloat volN[3] = {volNx, volNy, volNz};
            const dfloat N[3] = {nx, ny, nz};
            const dfloat T1[3] = {t1x, t1y, t1z};
            const dfloat T2[3] = {t2x, t2y, t2z};

            dfloat NCrossT1[3];
            crossProduct(N, T1, NCrossT1);

            dfloat volNCrossT1[3];
            crossProduct(volN, T1, volNCrossT1);

            dfloat T2CrossN[3];
            crossProduct(T2, N, T2CrossN);

            dfloat T2CrossVolN[3];
            crossProduct(T2, volN, T2CrossVolN);

            const dfloat dot1 = dot(NCrossT1, volNCrossT1);
            const dfloat dot2 = dot(T2CrossN, T2CrossVolN);

            const dfloat tolN = 1e-7;

            if(dot1 < tolN || (1.0 - dot1) < tolN) {
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 1.0;

            } else if(dot2 < tolN || (1.0 - dot2) < tolN) {
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 1.0;

              sgeo[sid * p_Nsgeo + p_T1XID] = T2[0];
              sgeo[sid * p_Nsgeo + p_T1YID] = T2[1];
              sgeo[sid * p_Nsgeo + p_T1ZID] = T2[2];

              sgeo[sid * p_Nsgeo + p_T2XID] = T1[0];
              sgeo[sid * p_Nsgeo + p_T2YID] = T1[1];
              sgeo[sid * p_Nsgeo + p_T2ZID] = T1[2];

            } else {
              // corner
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 0.0;
            }
          }

        }
      }
      @barrier("global");
    }
  }

}
