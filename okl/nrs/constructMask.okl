// Shared element edge of type p_ZERO_NORMAL is not supported.
@kernel void constructMask(const dlong Nelements,
                                         const dlong offset,
                                         @restrict const dfloat*  sgeo,
                                         @restrict const dlong*  vmapM,
                                         @restrict const int*  EToB,
                                         @restrict const dfloat*  normal,
                                         @restrict dfloat* mask)
{
  for(dlong e = 0; e < Nelements; e++; @outer(0)) {

    for(int f = 0; f < p_Nfaces; f++) {
      for(int m = 0; m < p_Nfp; ++m; @inner(0)) {
        const int n = m + f * p_Nfp;
        const int sk = e * p_Nfp * p_Nfaces + n;
        const dlong sid  = e * p_Nfaces * p_Nfp + n;
        const dlong idM = vmapM[sk];
        const dlong bcType = EToB[f + p_Nfaces * e];

        if(bcType == 7 || bcType == 8) {

          const dfloat nx = sgeo[sid * p_Nsgeo + p_NXID];
          const dfloat ny = sgeo[sid * p_Nsgeo + p_NYID];
          const dfloat nz = sgeo[sid * p_Nsgeo + p_NZID];
          const dfloat volNx = normal[idM + 0 * offset];
          const dfloat volNy = normal[idM + 1 * offset];
          const dfloat volNz = normal[idM + 2 * offset];

          // compare volumetric and face based normals
          // if they differ (e.g., an edge between two faces at a different angle),
          // apply zero to the mask
          const dfloat diffx = nx - volNx;
          const dfloat diffy = ny - volNy;
          const dfloat diffz = nz - volNz;
          const dfloat diff = sqrt(diffx * diffx + diffy * diffy + diffz * diffz);
          const dfloat tol = 1e-6;
          if(diff > tol) {
            mask[idM + 0 * offset] = 0.0;

            // TODO: need to zero out one of the tangentials, but not sure which one...
            mask[idM + 1 * offset] = 0.0;
            mask[idM + 2 * offset] = 0.0;
          }

        }
      }
      @barrier("global");
    }
  }

}
