@kernel void enforceUnHex3D(const dlong Nelements,
                                         const dlong offset,
                                         @restrict const dlong*  elementList,
                                         @restrict const dfloat*  V1,
                                         @restrict const dfloat*  V2,
                                         @restrict const dlong*  vmapM,
                                         @restrict const int*  EToB,
                                         @restrict const int*  BToBCType,
                                         @restrict outputType*  U)
{
  for(dlong element = 0; element < Nelements; element++; @outer(0)) {

    @exclusive dlong e;

    for(int f = 0; f < p_Nfaces; f++) {
      for(int m = 0; m < p_Nfp; ++m; @inner(0)) {
        e = elementList[element];
        const int n = m + f * p_Nfp;
        const int sk = e * p_Nfp * p_Nfaces + n;
        const dlong sid  = e * p_Nfaces * p_Nfp + n;
        const dlong idM = vmapM[sk];
        const dlong bid = EToB[f + p_Nfaces * e];

        const dlong bcType = bid >= 0 ? BToBCType[bid] : -1;

        if(bcType == p_ZERO_NORMAL) {

          const dfloat v1x = V1[sid * 3 + 0];
          const dfloat v1y = V1[sid * 3 + 1];
          const dfloat v1z = V1[sid * 3 + 2];

          const dfloat v2x = V2[sid * 3 + 0];
          const dfloat v2y = V2[sid * 3 + 1];
          const dfloat v2z = V2[sid * 3 + 2];


          const dfloat u = U[idM + 0 * offset];
          const dfloat v = U[idM + 1 * offset];
          const dfloat w = U[idM + 2 * offset];

          const dfloat Rtn1 = (u * v1x + v * v1y + w * v1z);
          const dfloat Rtn2 = (u * v2x + v * v2y + w * v2z);

          U[idM + 0 * offset] = outputType(Rtn1 * v1x + Rtn2 * v2x);
          U[idM + 1 * offset] = outputType(Rtn1 * v1y + Rtn2 * v2y);
          U[idM + 2 * offset] = outputType(Rtn1 * v1z + Rtn2 * v2z);
        }
      }
      @barrier("global");
    }

  }
}
