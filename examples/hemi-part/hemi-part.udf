//
// nekRS User Defined File
//
#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "udf.hpp"
#include "lpm/particle.hpp"

particles_t *particles;

/* Particle Functions */
void particleInit(particles_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  dlong partPerWire = 100;

  for (int line = 0; line < 4; ++line) { // 4 lines at different heights
    dfloat xp = -1.5;
    dfloat zp = .05 + line*0.075;
    for (int part = 0; part < partPerWire; ++part) {
      dfloat dy =  1.0*2/(partPerWire-1);
      dfloat yp = -1.0 + dy*part;

      if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
        particle_t particle;

        particle.x[0] = xp;
        particle.x[1] = yp;
        particle.x[2] = zp;
        particle.extra.id = gcount;
        for (int d = 0; d < 3; ++d) {
          particle.extra.v_hist[0][d] = 0.0;
          particle.extra.v_hist[1][d] = 0.0;
        }
//      particle.extra.color = time;    // color by spawning timestep
//      particle.extra.color = gcount;  // color by id
        particle.extra.color = line+1;  // color by line
//      particle.extra.color = yp;      // color by position in line

        p.push(particle);
      }
      ++gcount;
    }
  }
}

void applybounds(particles_t& p){
  // Remove particles that have left the region
  // outflow is at x=15
  if (p.x[0][i] > 15) {
    p.remove(i);
    --i; // cancel out the for loop increment
  }
}


void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new particles_t(nrs, 0);
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  // computing lambda2 requires the velocity on host
  if (nrs->isOutputStep) {
    nek::ocopyToNek(time, tstep);
    nek::userchk();
  }

  // adjust to control when particles are generated
  bool ifInit;
  static dfloat last_new_time = 0.0;    // |
  ifInit = time - last_new_time >= 0.5; // | every 0.5 seconds
  if(ifInit) last_new_time = time;      // |

  if (ifInit) {
    particleInit(*particles);
  }

  particles->update(nrs->o_U, nrs->dt, tstep);

  if (nrs->isOutputStep)  {
    particles->write(time);
  }
}