#include <math.h>
#include <numeric>
#include "udf.hpp"
#include "lpm/particle.hpp"
#include <omp.h>

/* UDF Functions */                                                      
static int nParticles;
static particles_t *particles;

/* Particle Functions */
void particleInit(particles_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // evenly distribute cubrt(nParticles)^3 particles in [0,1]^3

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
          particle_t particle;

          particle.x[0] = xp;
          particle.x[1] = yp;
          particle.x[2] = zp;
          particle.extra.id = gcount;
          for (int d = 0; d < 3; ++d) {
            particle.extra.v_hist[0][d] = 0.0;
            particle.extra.v_hist[1][d] = 0.0;
          }
          particle.extra.color = gcount;  // color by id

          p.push(particle);
        }
        ++gcount; // Total count
      }
    }
  }
}

// apply periodicity for particles on [0,1]^3
void applyBounds(particles_t& p) {

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  for (int i = 0; i < p.size(); ++i) {
    // x and z have periodic boundaries
    if (p.x[0][i] > Lx) p.x[0][i] -= Lx;
    if (p.x[0][i] < 0) p.x[0][i] += Lx;

    if (p.x[1][i] > Lx) p.x[0][i] -= Lx;
    if (p.x[1][i] < 0) p.x[0][i] += Lx;

    if (p.x[2][i] > Lz) p.x[2][i] -= Lz;
    if (p.x[2][i] < 0) p.x[2][i] += Lz;
  }
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  if(platform->comm.mpiCommSize > 1){
    printf("Particles test must be called with exactly 1 MPI rank.\n");
    ABORT(1);
  }
  platform->par->extract("casedata", "p_nparticles", nParticles);
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new particles_t(nrs, 0);
}

double run(nrs_t* nrs, particles_t& particles, int Ntrials, std::array<dfloat, 3>& dt)
{
  platform->device.finish();
  MPI_Barrier(platform->comm.mpiComm);
  const double start = MPI_Wtime();

  for(int tstep = 1; tstep <= Ntrials; ++tstep){
    particles.update(nrs->o_U, dt.data(), tstep);
    applyBounds(particles);
  }

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  return (MPI_Wtime() - start) / Ntrials;
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat /** unused **/, int /** unused **/)
{
  auto * mesh = nrs->meshV;

  particleInit  (*particles);

  int Nstep = 10;
  std::array<dfloat, 3> dt = {1.0 / Nstep, 1.0 / Nstep, 1.0 / Nstep};

  auto o_U_x = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
  auto o_U_y = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
  auto o_U_z = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

  platform->linAlg->fill(mesh->Nlocal, 1.0, o_U_x);
  platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_y);
  platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_z);

  // will integrate for 1 time unit -- puts particles back at original location
  double elapsed = run(nrs, *particles, 10, dt);

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  std::vector<dfloat> expectedX(nParticles, 0.0);
  std::vector<dfloat> expectedY(nParticles, 0.0);
  std::vector<dfloat> expectedZ(nParticles, 0.0);
  
  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  dlong particleCtr = 0.0;
  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        expectedX[particleCtr] = xp;
        expectedY[particleCtr] = yp;
        expectedZ[particleCtr] = zp;
        particleCtr++;
      }
    }
  }

  dfloat errPos = 0.0;

  for(int i = 0; i < particles->size(); ++i){
    errPos += std::abs(particles->x[0][i] - expectedX[i]);
    errPos += std::abs(particles->x[1][i] - expectedY[i]);
    errPos += std::abs(particles->x[2][i] - expectedZ[i]);
  }

  errPos /= nParticles;

  std::cout << "Error in position: " << errPos << "\n";

  const dfloat testTol = 1e-12;

  if(errPos > testTol){
    std::cout << "Error too large. Failing test!\n";
    MPI_Finalize();
    exit(2);
  }

  // done with correctness check...

  // Now the benchmark:
  const int elapsedTarget = 10;
  const int Ntests = elapsedTarget / elapsed;

  elapsed = run(nrs, *particles, Ntests, dt);

  double particleThroughput = (nParticles / elapsed) / 1.e9;

  const int Nthreads =  omp_get_max_threads();

  dlong globalElements = mesh->Nelements;

  MPI_Allreduce(MPI_IN_PLACE, &globalElements, 1, MPI_DLONG, MPI_SUM, platform->comm.mpiComm);

  if(platform->comm.mpiRank == 0){
    std::cout << "MPItasks=" << platform->comm.mpiCommSize
              << " OMPthreads=" << Nthreads
              << " NRepetitions=" << Ntests
              << " N=" << mesh->N
              << " Nelements=" << globalElements
              << " elapsed time=" << elapsed
              << " GParticles/s=" << particleThroughput
              << "\n";
  }

  EXIT_AND_FINALIZE(0);
}
