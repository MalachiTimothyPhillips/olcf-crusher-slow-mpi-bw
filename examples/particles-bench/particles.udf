#include <math.h>
#include <numeric>
#include "udf.hpp"
#include "lpm/particle.hpp"

/* UDF Functions */                                                      
static int nParticles;
static particles_t *particles;

/* Particle Functions */
void particleInit(particles_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // evenly distribute cubrt(nParticles)^3 particles in [0,1]^3

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
          particle_t particle;

          particle.x[0] = xp;
          particle.x[1] = yp;
          particle.x[2] = zp;
          particle.extra.id = gcount;
          for (int d = 0; d < 3; ++d) {
            particle.extra.v_hist[0][d] = 0.0;
            particle.extra.v_hist[1][d] = 0.0;
          }
          particle.extra.color = gcount;  // color by id

          p.push(particle);
        }
        ++gcount; // Total count
      }
    }
  }
}

// apply periodicity for particles on [0,1]^3
void applyBounds(particles_t& p) {

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  for (int i = 0; i < p.size(); ++i) {
    // x and z have periodic boundaries
    if (p.x[0][i] > Lx) p.x[0][i] -= Lx;
    if (p.x[0][i] < 0) p.x[0][i] += Lx;

    if (p.x[1][i] > Lx) p.x[0][i] -= Lx;
    if (p.x[1][i] < 0) p.x[0][i] += Lx;

    if (p.x[2][i] > Lz) p.x[2][i] -= Lz;
    if (p.x[2][i] < 0) p.x[2][i] += Lz;
  }
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  if(platform->comm.mpiCommSize > 1){
    printf("Particles test must be called with exactly 1 MPI rank.\n");
    ABORT(1);
  }
  platform->par->extract("casedata", "p_nparticles", nParticles);
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new particles_t(nrs, 0);
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat /** unused **/, int /** unused **/)
{
  auto * mesh = nrs->meshV;

  particleInit  (*particles);

  constexpr int Nstep = 10;
  std::array<dfloat, 3> dt = {1.0 / Nstep, 1.0 / Nstep, 1.0 / Nstep};

  auto o_U_x = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
  auto o_U_y = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
  auto o_U_z = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

  platform->linAlg->fill(mesh->Nlocal, 1.0, o_U_x);
  platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_y);
  platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_z);

  const dfloat Tfinal = Nstep * dt[0];

  // each particle should have migrated 1 unit in x, e.g., at initial position

  for(int tstep = 1; tstep < Nstep; ++tstep){
    particles->update(nrs->o_U, dt.data(), tstep);
    applyBounds(*particles);
  }

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  std::vector<dfloat> expectedX(nParticles, 0.0);
  std::vector<dfloat> expectedY(nParticles, 0.0);
  std::vector<dfloat> expectedZ(nParticles, 0.0);
  
  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  dlong particleCtr = 0.0;
  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        expectedX[particleCtr] = xp;
        expectedY[particleCtr] = yp;
        expectedZ[particleCtr] = zp;
        particleCtr++;
      }
    }
  }

  dfloat errPos = 0.0;

  for(int i = 0; i < particles->size(); ++i){
    errPos += std::abs(particles->x[0][i] - expectedX[i]);
    errPos += std::abs(particles->x[1][i] - expectedY[i]);
    errPos += std::abs(particles->x[2][i] - expectedZ[i]);
  }

  std::cout << "Error in position: " << errPos << "\n";





  EXIT_AND_FINALIZE(0);
}
