#include <math.h>
#include <numeric>
#include "udf.hpp"
#include "lpm/particle.hpp"
#include <omp.h>

/* UDF Functions */                                                      
static int nParticles;
static lpm_t *particles;

enum class BENCHMARK{
  FINDPTS_LOCAL,
  FINDPTS_LOCAL_EVAL,
  PARTICLE_UPDATE,
  INVALID,
};

BENCHMARK benchmarkMode;

BENCHMARK ciModeToBenchmark(dlong mode)
{
  if(mode == 1){
    return BENCHMARK::FINDPTS_LOCAL;
  }
  if(mode == 2){
    return BENCHMARK::FINDPTS_LOCAL_EVAL;
  }
  if(mode == 3){
    return BENCHMARK::PARTICLE_UPDATE;
  }

  return BENCHMARK::INVALID;
}


/* Particle Functions */
void particleInit(lpm_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // evenly distribute cubrt(nParticles)^3 particles in [0,1]^3

  int nParticleDir = std::round(std::cbrt(nParticles));
  nParticles = nParticleDir * nParticleDir * nParticleDir;

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  const dfloat invNParticleDir = 1.0 / nParticleDir;

  for (int ix = 0; ix < nParticleDir; ++ix) {
    for (int iy = 0; iy < nParticleDir; ++iy) {
      for (int iz = 0; iz < nParticleDir; ++iz) {

        dfloat dx = Lx * invNParticleDir;
        dfloat dy = Ly * invNParticleDir;
        dfloat dz = Lz * invNParticleDir;

        dfloat xp = dx*(ix+0.5);
        dfloat yp = dy*(iy+0.5);
        dfloat zp = dz*(iz+0.5);

        if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
          particle_t particle;

          particle.x = xp;
          particle.y = yp;
          particle.z = zp;
          p.push(particle);
        }
        ++gcount; // Total count
      }
    }
  }
}

// apply periodicity for particles on [0,1]^3
void applyBounds(lpm_t& p) {

  const dfloat Lx = 1.0;
  const dfloat Ly = 1.0;
  const dfloat Lz = 1.0;

  for (int i = 0; i < p.size(); ++i) {
    // x and z have periodic boundaries
    if (p.x(i) > Lx) {
      p.x(i) -= Lx;
    }
    if (p.x(i) < 0) {
      p.x(i) += Lx;
    }
    if (p.y(i) > Lx) {
      p.y(i) -= Lx;
    }
    if (p.y(i) < 0) {
      p.y(i) += Lx;
    }
    if (p.z(i) > Lz) {
      p.z(i) -= Lz;
    }
    if (p.z(i) < 0) {
      p.z(i) += Lz;
    }
  }
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  if(platform->comm.mpiCommSize > 1){
    printf("Particles test must be called with exactly 1 MPI rank.\n");
    ABORT(1);
  }
  platform->par->extract("casedata", "p_nparticles", nParticles);

  int ciMode;
  options.getArgs("CI-MODE", ciMode);
  benchmarkMode = ciModeToBenchmark(ciMode);

  if(benchmarkMode == BENCHMARK::INVALID){
    printf("Invalid benchmark mode specified!\n");
    ABORT(1);
  }
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new lpm_t(nrs, 0);
}

double run_particle_update(nrs_t* nrs, lpm_t& particles, int Ntrials, std::array<dfloat, 3>& dt)
{
  platform->device.finish();
  MPI_Barrier(platform->comm.mpiComm);
  const double start = MPI_Wtime();

  for(int tstep = 1; tstep <= Ntrials; ++tstep){
    particles.update(nrs->o_U, dt.data(), tstep);
    applyBounds(particles);
  }

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  return (MPI_Wtime() - start) / Ntrials;
}

double run_findpts_local_bench(nrs_t* nrs, lpm_t& particles, int Ntrials)
{
  const auto pn = particles.size();

  std::vector<dfloat> dist2(pn, 0.0);
  std::vector<dfloat> x(pn, 0.0);
  std::vector<dfloat> y(pn, 0.0);
  std::vector<dfloat> z(pn, 0.0);

  std::vector<dlong> code(pn, 0);
  std::vector<dlong> proc(pn, 0);
  std::vector<dlong> el(pn, 0);
  std::vector<dfloat> r(3*pn, 0.0);

  for(int p = 0; p < particles.size(); ++p){
    x[p] = particles.x(p);
    y[p] = particles.y(p);
    z[p] = particles.z(p);
  }

  ogs_findpts_data_t data(code.data(), proc.data(), el.data(), r.data(), dist2.data());

  const std::array<dlong, 3> xStrideBytes = {sizeof(dfloat), sizeof(dfloat), sizeof(dfloat)};

  auto findpts = particles.interp().ptr();

  occa::memory  d_code_base = platform->device.malloc(  sizeof(dlong) *pn);
  occa::memory    d_el_base = platform->device.malloc(  sizeof(dlong) *pn);
  occa::memory     d_r_base = platform->device.malloc(3*sizeof(dfloat)*pn);
  occa::memory d_dist2_base = platform->device.malloc(  sizeof(dfloat)*pn);
  occa::memory     d_x_base = platform->device.malloc(3*sizeof(dfloat*)  );
  occa::memory    d_x0_base = platform->device.malloc( xStrideBytes[0]*pn);
  occa::memory    d_x1_base = platform->device.malloc( xStrideBytes[1]*pn);
  occa::memory    d_x2_base = platform->device.malloc( xStrideBytes[2]*pn);
  occa::memory   d_x_stride = platform->device.malloc(3*sizeof(dlong)    );

  dfloat *x_base_d[3] = {(double*)d_x0_base.ptr(), (double*)d_x1_base.ptr(), (double*)d_x2_base.ptr()};
  d_x_base.copyFrom(x_base_d, 3*sizeof(dfloat*));
  d_x0_base.copyFrom(x.data(), xStrideBytes[0]*pn);
  d_x1_base.copyFrom(y.data(), xStrideBytes[1]*pn);
  d_x2_base.copyFrom(z.data(), xStrideBytes[2]*pn);
  d_x_stride.copyFrom(xStrideBytes.data(), 3*sizeof(dlong));

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto start = MPI_Wtime();
  {
    for(int i = 0; i < Ntrials; ++i){
      findpts->local_kernel( d_code_base,sizeof(dlong),
                              d_el_base, sizeof(dlong),
                               d_r_base, 3*sizeof(dfloat),
                           d_dist2_base, sizeof(dfloat),
                               d_x_base, d_x_stride,
                           pn, findpts->o_fd_local);
    }
  }
  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto end = MPI_Wtime();

  d_code_base.free();
  d_el_base.free();
  d_r_base.free();
  d_dist2_base.free();
  d_x_base.free();
  d_x0_base.free();
  d_x1_base.free();
  d_x2_base.free();
  d_x_stride.free();

  return (end - start) / Ntrials;
}

double run_findpts_local_eval_bench(nrs_t* nrs, lpm_t& particles, int Ntrials)
{

  const auto Np = nrs->meshV->Np;

  const auto pn = particles.size();

  std::vector<std::array<dfloat, 3>> r(pn, {0.0, 0.0, 0.0});
  std::vector<dlong> code(pn, 0);
  std::vector<dlong> proc(pn, 0);
  std::vector<dlong> el(pn, 0);

  for(int p = 0; p < pn; ++p){
    auto particle = particles[p];
    code[p] = particle.code;
    proc[p] = particle.proc;
    el[p] = particle.el;
    r[p] = particle.r;
  }

  constexpr int nFields = 3;

  occa::memory o_out = platform->device.malloc(nFields * pn * sizeof(dfloat));
  occa::memory o_r   = platform->device.malloc(3 * pn * sizeof(dfloat));
  occa::memory o_el =  platform->device.malloc(pn * sizeof(dlong));

  o_r.copyFrom(&(r.data()[0][0]), 3 * pn * sizeof(dfloat));
  o_el.copyFrom(el.data(), pn * sizeof(dlong));

  auto o_Ux = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
  auto o_Uy = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
  auto o_Uz = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

  auto o_outx = o_out + 0 * pn * sizeof(dfloat);
  auto o_outy = o_out + 1 * pn * sizeof(dfloat);
  auto o_outz = o_out + 2 * pn * sizeof(dfloat);

  auto* findpts = particles.interp().ptr();

  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);
  const auto start = MPI_Wtime();
  {
    for(int i = 0; i < Ntrials; ++i){
#define VERSION 3
#if VERSION == 1
      findpts->local_eval_kernel(1, 0, 0, o_outx, sizeof(dfloat),
                                o_el,  sizeof(dlong),
                                o_r,   3 * sizeof(dfloat),
                                pn, o_Ux,
                                findpts->o_fd_local);

      findpts->local_eval_kernel(1, 0, 0, o_outy, sizeof(dfloat),
                                o_el,  sizeof(dlong),
                                o_r,   3 * sizeof(dfloat),
                                pn, o_Uy,
                                findpts->o_fd_local);

      findpts->local_eval_kernel(1, 0, 0, o_outz, sizeof(dfloat),
                                o_el,  sizeof(dlong),
                                o_r,   3 * sizeof(dfloat),
                                pn, o_Uz,
                                findpts->o_fd_local);
#elif VERSION == 2
      findpts->local_eval_kernel(3, pn, nrs->fieldOffset, o_out, sizeof(dfloat),
                                o_el,  sizeof(dlong),
                                o_r,   3 * sizeof(dfloat),
                                pn, nrs->o_U,
                                findpts->o_fd_local);
#elif VERSION == 3
      findpts->local_eval_vector_kernel(pn, nrs->fieldOffset, o_out, sizeof(dfloat),
                                o_el,  sizeof(dlong),
                                o_r,   3 * sizeof(dfloat),
                                pn, nrs->o_U,
                                findpts->o_fd_local);
#endif
    }
  }
  platform->device.finish();
  MPI_Barrier(MPI_COMM_WORLD);

  const auto end = MPI_Wtime();

  o_out.free();
  o_r.free();
  o_el.free();

  return (end - start) / Ntrials;
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat /** unused **/, int /** unused **/)
{
  auto * mesh = nrs->meshV;

  particleInit  (*particles);

  if(benchmarkMode == BENCHMARK::FINDPTS_LOCAL)
  {
    double elapsed = run_findpts_local_bench(nrs, *particles, 10);
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;
    elapsed = run_findpts_local_bench(nrs, *particles, Ntests);

    const auto nParticles = particles->size();

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "findpts_local kernel:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
    }

    EXIT_AND_FINALIZE(0);
  }

  if(benchmarkMode == BENCHMARK::FINDPTS_LOCAL_EVAL)
  {
    // set up data for findpts_local_eval call
    std::array<dfloat, 3> dt = {0.1, 0.1, 0.1};
    particles->update(nrs->o_U, dt.data(), 1);

    double elapsed = run_findpts_local_eval_bench(nrs, *particles, 10);
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;
    elapsed = run_findpts_local_eval_bench(nrs, *particles, Ntests);

    const auto nParticles = particles->size();

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "findpts_local_eval kernel:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
    }

    EXIT_AND_FINALIZE(0);

  }

  if(benchmarkMode == BENCHMARK::PARTICLE_UPDATE)
  {
    int Nstep = 10;
    std::array<dfloat, 3> dt = {1.0 / Nstep, 1.0 / Nstep, 1.0 / Nstep};

    auto o_U_x = nrs->o_U + 0 * nrs->fieldOffset * sizeof(dfloat);
    auto o_U_y = nrs->o_U + 1 * nrs->fieldOffset * sizeof(dfloat);
    auto o_U_z = nrs->o_U + 2 * nrs->fieldOffset * sizeof(dfloat);

    platform->linAlg->fill(mesh->Nlocal, 1.0, o_U_x);
    platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_y);
    platform->linAlg->fill(mesh->Nlocal, 0.0, o_U_z);

    // will integrate for 1 time unit -- puts particles back at original location
    double elapsed = run_particle_update(nrs, *particles, 10, dt);

    int nParticleDir = std::round(std::cbrt(nParticles));
    nParticles = nParticleDir * nParticleDir * nParticleDir;

    std::vector<dfloat> expectedX(nParticles, 0.0);
    std::vector<dfloat> expectedY(nParticles, 0.0);
    std::vector<dfloat> expectedZ(nParticles, 0.0);
  
    const dfloat Lx = 1.0;
    const dfloat Ly = 1.0;
    const dfloat Lz = 1.0;

    const dfloat invNParticleDir = 1.0 / nParticleDir;

    dlong particleCtr = 0.0;
    for (int ix = 0; ix < nParticleDir; ++ix) {
      for (int iy = 0; iy < nParticleDir; ++iy) {
        for (int iz = 0; iz < nParticleDir; ++iz) {

          dfloat dx = Lx * invNParticleDir;
          dfloat dy = Ly * invNParticleDir;
          dfloat dz = Lz * invNParticleDir;

          dfloat xp = dx*(ix+0.5);
          dfloat yp = dy*(iy+0.5);
          dfloat zp = dz*(iz+0.5);

          expectedX[particleCtr] = xp;
          expectedY[particleCtr] = yp;
          expectedZ[particleCtr] = zp;
          particleCtr++;
        }
      }
    }

    dfloat errPos = 0.0;

    for(int i = 0; i < particles->size(); ++i){
      errPos += std::abs(particles->x(i) - expectedX[i]);
      errPos += std::abs(particles->y(i) - expectedY[i]);
      errPos += std::abs(particles->z(i) - expectedZ[i]);
    }

    errPos /= nParticles;

    std::cout << "Error in position: " << errPos << "\n";

    const dfloat testTol = 1e-12;

    if(errPos > testTol){
      std::cout << "Error too large. Failing test!\n";
      MPI_Finalize();
      exit(2);
    }

    // done with correctness check...

    // Now the benchmark:
    const int elapsedTarget = 10;
    const int Ntests = elapsedTarget / elapsed;

    elapsed = run_particle_update(nrs, *particles, Ntests, dt);

    double particleThroughput = (nParticles / elapsed) / 1.e9;

    const int Nthreads =  omp_get_max_threads();

    if(platform->comm.mpiRank == 0){
      std::cout << "particle update:\n";
      std::cout << "MPItasks=" << platform->comm.mpiCommSize
                << " OMPthreads=" << Nthreads
                << " NRepetitions=" << Ntests
                << " N=" << mesh->N
                << " Nelements=" << mesh->Nelements
                << " Nparticles=" << nParticles
                << " elapsed time=" << elapsed
                << " GParticles/s=" << particleThroughput
                << "\n";
    }

    const double tUpdate      = platform->timer.query("lpm_t::update", "DEVICE:MAX");
    const double tFind        = platform->timer.query("lpm_t::find", "DEVICE:MAX");
    const double tMigrate     = platform->timer.query("lpm_t::migrate", "DEVICE:MAX");
    const double tInterpLocal = platform->timer.query("lpm_t::interpLocal", "DEVICE:MAX");
    const double tAdvance     = platform->timer.query("lpm_t::advance", "DEVICE:MAX");
    std::cout <<   "lpm_t::update           " << tUpdate << "s\n";
    std::cout <<   "  lpm_t::find           " << tFind << "s\n";
    std::cout <<   "  lpm_t::migrate        " << tMigrate << "s\n";
    std::cout <<   "  lpm_t::interpLocal    " << tInterpLocal << "s\n";
    std::cout <<   "  lpm_t::advance        " << tAdvance << "s\n";

    EXIT_AND_FINALIZE(0);
  }
}