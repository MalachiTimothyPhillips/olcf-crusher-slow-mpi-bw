//
// nekRS User Defined File
//
#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "udf.hpp"
#include "lpm/particle.hpp"

#include "casedata.h"

static particles_t *particles;
static occa::kernel coriolisKernel;

/* Particle Functions */
void particleInit(particles_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // evenly distribute 50^3 particles in (0.0, 4.0)x(0.0, 4.0)x(0.0, 4.0)
  for (int ix = 0; ix < 50; ++ix) {
    for (int iy = 0; iy < 50; ++iy) {
      for (int iz = 0; iz < 50; ++iz) {

        dfloat dx = 4.0/50,      dy = 4.0/50,      dz = 4.0/50;
        dfloat xp = dx*(ix+0.5), yp = dy*(iy+0.5), zp = dz*(iz+0.5);

        if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
          particle_t particle;

          particle.x[0] = xp;
          particle.x[1] = yp;
          particle.x[2] = zp;
          particle.extra.id = gcount;
          for (int d = 0; d < 3; ++d) {
            particle.extra.v_hist[0][d] = 0.0;
            particle.extra.v_hist[1][d] = 0.0;
          }
          particle.extra.color = gcount;  // color by id

          p.push(particle);
        }
        ++gcount; // Total count
      }
    }
  }
}

void applyBounds(particles_t& p) {

  for (int i = 0; i < p.size(); ++i) {
    // x and z have periodic boundaries
    if (p.x[0][i] > 4) p.x[0][i] -= 4;
    if (p.x[0][i] < 0) p.x[0][i] += 4;
    if (p.x[2][i] > 4) p.x[2][i] -= 4;
    if (p.x[2][i] < 0) p.x[2][i] += 4;
    // don't let particles enter the ground
    if (p.x[1][i] < 0) p.x[1][i] = 0;
  }
}

void userf(nrs_t *nrs, dfloat time, occa::memory o_U, occa::memory o_FU)
{
  mesh_t* mesh = nrs->meshV;
  coriolisKernel(
    mesh->Nlocal,
    nrs->fieldOffset,
    nrs->meshV->o_y,
    nrs->cds->o_S,
    nrs->o_U,
    o_FU);
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  setupAide &options = platform->options;

  dfloat cond;
  options.getArgs("SCALAR00 DIFFUSIVITY", cond);
  const dfloat g = 9.81;
  const dfloat omega = 7.2921159e-5;

  kernelInfo["defines/p_fcor"]      = 2*omega*LREF/UREF * sin(NLAT*M_PI/180);
  kernelInfo["defines/p_bcor"]      = 2*omega*LREF/UREF * cos(NLAT*M_PI/180);
  kernelInfo["defines/p_gacc"]      = LREF*g/(UREF*UREF);
  kernelInfo["defines/p_cond"]      = cond;
  kernelInfo["defines/p_TsGrad"]    = ILSTRENGTH * LREF/TREF;
  kernelInfo["defines/p_T0s"]       = TS0/TREF;
  kernelInfo["defines/p_sCoolRate"] = SCR * LREF/TREF/UREF/3600;
  kernelInfo["defines/p_YLEN"]      = YLEN;

  coriolisKernel = oudfBuildKernel(kernelInfo, "coriolis");
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new particles_t(nrs, 0);
  udf.uEqnSource = &userf;
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  const bool ifInit = tstep == 0; // only once at the begining

  if (ifInit) {
    particleInit  (*particles);
  }

  particles->update(nrs->o_U, nrs->dt, tstep);

  applyBounds(*particles);

  if (nrs->isOutputStep)  {
    particles->write();
  }
}
