#include <math.h>
#include "udf.hpp"

/* UDF Functions */                                                      
static dfloat P_EPS;

int n,nx,ny,nz,P,lnull;

occa::kernel TCx, TCy, TCz, Dot;
occa::kernel SemToSlab, SlabToSem;

occa::memory device_Sx, device_Sy, device_Sz;
occa::memory device_Sxt, device_Syt, device_Szt;
occa::memory device_Di, device_b, device_ans, device_tmp;
occa::memory device_Sem, device_Slab, device_Sem2, device_Sptr;

double *host_exact;
double *host_ans;
double *host_sem;
double *host_slab;

/* UDF Functions */
void FDMoperator_viral(nrs_t *nrs,  occa::memory device_rhs){
  SemToSlab(device_rhs, device_Slab, device_Sptr, lnull, n);
  TCx(device_Syt, device_Slab,device_ans, ny, nx, nz);
  TCy(device_Sxt, device_ans, device_tmp, ny, nx, nz);
  TCz(device_Szt, device_tmp, device_ans, ny, nx, nz);
  Dot(device_Di,  device_ans, device_tmp, ny, nx, nz);
  TCx(device_Sy,  device_tmp, device_ans, ny, nx, nz);
  TCy(device_Sx,  device_ans, device_tmp, ny, nx, nz);
  TCz(device_Sz,  device_tmp, device_ans, ny, nx, nz);
  SlabToSem(device_Sem, device_ans, device_Sptr, lnull, n);
  oogs::startFinish(device_Sem, 1, nrs->fieldOffset, ogsDfloat, ogsAdd, nrs->gsh);
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  TCx = udfBuildKernel(kernelInfo, "TCx");
  TCy = udfBuildKernel(kernelInfo, "TCy");
  TCz = udfBuildKernel(kernelInfo, "TCz");
  Dot = udfBuildKernel(kernelInfo, "Dot");
  SemToSlab = udfBuildKernel(kernelInfo, "SemToSlab");
  SlabToSem = udfBuildKernel(kernelInfo, "SlabToSem");
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.setArgs("PRESSURE PRECONDITIONER", "USER");
  platform->par->extract("casedata", "p_eps", P_EPS);
  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double* const nek_cb_scnrs = (double*) nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = P_EPS;
  }
}

void UDF_Setup(nrs_t *nrs)
{
  platform->options.setArgs("LINEAR SOLVER STOPPING CRITERION", "RELATIVE");

  double *h_data = (double*)nek::scPtr(1);
  n = (int)h_data[0];
  nx = (int)h_data[1];
  ny = (int)h_data[2];
  nz = (int)h_data[3];
  P = (int)h_data[4];
  lnull = (int)h_data[5];

  double *host_sptr = (double*)nek::scPtr(2);
  double *host_Sx   = (double*)nek::scPtr(3);
  double *host_Sy   = (double*)nek::scPtr(4);
  double *host_Sz   = (double*)nek::scPtr(5);
  double *host_Sxt  = (double*)nek::scPtr(6);
  double *host_Syt  = (double*)nek::scPtr(7);
  double *host_Szt  = (double*)nek::scPtr(8);
  double *host_Di   = (double*)nek::scPtr(9);

  host_ans   = new dfloat[n];
  host_exact = new dfloat[n];
  host_sem  = new dfloat[n];
  host_slab = new dfloat[nx*ny*nz+1];

  int *host_sptri = new int[n];
  for(int i=0; i<n; i++){
    host_sptri[i] = (int)host_sptr[i];
  }

  device_Sptr = platform->device.malloc( n * sizeof(int) );
  device_Sx   = platform->device.malloc( nx*nx * sizeof(dfloat));
  device_Sy   = platform->device.malloc( ny*ny * sizeof(dfloat) );
  device_Sz   = platform->device.malloc( nz*nz * sizeof(dfloat) );
  device_Sxt  = platform->device.malloc( nx*nx * sizeof(dfloat) );
  device_Syt  = platform->device.malloc( ny*ny * sizeof(dfloat) );
  device_Szt  = platform->device.malloc( nz*nz * sizeof(dfloat) );
  device_Di   = platform->device.malloc( nx*ny*nz * sizeof(dfloat) );
  device_ans  = platform->device.malloc( (nx*ny*nz+1) * sizeof(dfloat) );
  device_tmp  = platform->device.malloc( (nx*ny*nz+1) * sizeof(dfloat) );
  device_Slab = platform->device.malloc( (nx*ny*nz+1) * sizeof(dfloat) );
  device_Sem  = platform->device.malloc( n * sizeof(dfloat) );
  device_Sem2 = platform->device.malloc( n * sizeof(dfloat) );

  device_Sptr.copyFrom(host_sptri);
  device_Sx.copyFrom(host_Sx);
  device_Sy.copyFrom(host_Sy);
  device_Sz.copyFrom(host_Sz);
  device_Sxt.copyFrom(host_Sxt);
  device_Syt.copyFrom(host_Syt);
  device_Szt.copyFrom(host_Szt);
  device_Di.copyFrom(host_Di);

}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  nrs->pSolver->userPreconditioner = [=](occa::memory & o_r, occa::memory & o_z)
  {
    FDMoperator_viral(nrs, o_r);
    device_Sem.copyTo(o_z, nrs->meshV->Nlocal * sizeof(dfloat));
  };
  mesh_t* mesh = nrs->meshV;

  for (int i = 0; i < mesh->Nlocal; i++) {
    const dfloat lambda = 0; 
    platform->mempool.slice0[i] = //drand48(); 
      (3*M_PI*M_PI+lambda)*sin(M_PI*mesh->x[i])*sin(M_PI*mesh->y[i])*sin(M_PI*mesh->z[i]);
  }
  platform->linAlg->fillKernel(mesh->Nlocal, 1.0, nrs->o_ellipticCoeff);
  platform->o_mempool.slice0.copyFrom(platform->mempool.slice0, mesh->Nlocal * sizeof(dfloat));

  // warm-up
  ellipticSolve(nrs->pSolver, platform->o_mempool.slice0, nrs->o_P);
  platform->timer.reset("pressureSolve");

  const int Nrep = 10; 
  if(platform->comm.mpiRank == 0) printf("solving "); 
  for (int i = 0; i < Nrep; i++) { 
    platform->linAlg->fillKernel(mesh->Nlocal, 0.0, nrs->o_P);
    platform->o_mempool.slice0.copyFrom(platform->mempool.slice0, mesh->Nlocal * sizeof(dfloat));

    platform->timer.tic("pressureSolve", 1);
    ellipticSolve(nrs->pSolver, platform->o_mempool.slice0, nrs->o_P);
    platform->timer.toc("pressureSolve");
    
    if(platform->comm.mpiRank == 0) {
      printf(".");
      fflush(stdout); 
    }
  }

  if(platform->comm.mpiRank == 0) printf("\n"); 

  hlong Ntotal = mesh->Nelements * (mesh->N * mesh->N * mesh->N);
  MPI_Allreduce(MPI_IN_PLACE, &Ntotal, 1, MPI_HLONG, MPI_SUM, platform->comm.mpiComm);
  const double solveTime = platform->timer.query("pressureSolve", "DEVICE:MAX")/Nrep;
  const double precoTime = platform->timer.query("pressure preconditioner", "DEVICE:MAX")/Nrep;
  const double smootherTime = platform->timer.query("pressure preconditioner smoother", "DEVICE:MAX")/Nrep;
  const double crsTime = [&](){
    const double tBoomerAMG = platform->timer.query("BoomerAMGSolve", "HOST:MAX")/Nrep;
    const double tAMGX = platform->timer.query("AmgXSolve", "DEVICE:MAX")/Nrep;
    const double tCrsSEMFEM = platform->timer.query("Coarse SEMFEM Solve", "DEVICE:MAX")/Nrep;
    const double maxTime = tBoomerAMG > tAMGX ? tBoomerAMG : tAMGX;
    return maxTime > tCrsSEMFEM ? maxTime : tCrsSEMFEM;
  }();
  if(platform->comm.mpiRank == 0) {
    const double throughput = (double)Ntotal/solveTime;
    printf("iterations: %d\n", nrs->pSolver->Niter);
    printf("avg solve time: %g s\n", solveTime);
    printf("  preconditioner %g s\n", precoTime);
    if(smootherTime > 0) printf("    smoother %g s\n", smootherTime);
    if(crsTime > 0) printf("    coarse grid %g s\n", crsTime);
    printf("avg throughput: %g DOF/s\n", throughput);
    printf("avg throughput: %g (DOF x iter)/s\n", (double) nrs->pSolver->Niter * throughput);
  }
}



                                                      
