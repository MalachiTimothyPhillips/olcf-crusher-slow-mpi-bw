#include <math.h>
#include "udf.hpp"
#include <array>

/* UDF Functions */                                                      
static dfloat P_EPS;

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  platform->par->extract("casedata", "p_eps", P_EPS);
  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double* const nek_cb_scnrs = (double*) nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = P_EPS;
  }
}

void UDF_Setup(nrs_t *nrs)
{
}

void randomVector(dfloat* x, elliptic_t* pSolver)
{
  for (int i = 0; i < pSolver->mesh->Nlocal; i++) {
    x[i] = drand48(); 
  }
  ogsGatherScatter(x, ogsDfloat, ogsAdd, pSolver->mesh->ogs);
  for (dlong i = 0; i < pSolver->Nmasked; i++) x[pSolver->maskIds[i]] = 0.;
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  mesh_t* mesh = nrs->meshV;
  elliptic_t* pSolver = nrs->pSolver;

  for (int i = 0; i < mesh->Nlocal; i++) {
    const dfloat lambda = 0; 
    platform->mempool.slice0[i] = //drand48(); 
      (3*M_PI*M_PI+lambda)*sin(M_PI*mesh->x[i])*sin(M_PI*mesh->y[i])*sin(M_PI*mesh->z[i]);
  }
  platform->o_mempool.slice0.copyFrom(platform->mempool.slice0, mesh->Nlocal * sizeof(dfloat));

  randomVector(platform->mempool.slice1, pSolver);
  platform->o_mempool.slice1.copyFrom(platform->mempool.slice1, mesh->Nlocal * sizeof(dfloat));
  ellipticOperator(pSolver, platform->o_mempool.slice1, platform->o_mempool.slice2, dfloatString);

  // RHS = b_0 + Ax (x is a random, continous vector obeying the BCs)
  platform->linAlg->axpbyz(
    mesh->Nlocal,
    1.0,
    platform->o_mempool.slice0,
    1.0,
    platform->o_mempool.slice2,
    platform->o_mempool.slice3
  );


  platform->linAlg->fillKernel(mesh->Nlocal, 1.0, nrs->o_ellipticCoeff);

  // warm-up
  ellipticSolve(nrs->pSolver, platform->o_mempool.slice3, nrs->o_P);
  platform->timer.reset("pressureSolve");
  platform->timer.reset("pressure preconditioner");
  platform->timer.reset("pressure preconditioner smoother");
  platform->timer.reset("coarseSolve");

  constexpr int Nrep = 10; 
  std::array<double, Nrep> iterations;
  if(platform->comm.mpiRank == 0) printf("solving "); 
  for (int i = 0; i < Nrep; i++) { 
    platform->linAlg->fillKernel(mesh->Nlocal, 0.0, nrs->o_P);
    platform->o_mempool.slice0.copyFrom(platform->mempool.slice0, mesh->Nlocal * sizeof(dfloat));

    randomVector(platform->mempool.slice1, pSolver);
    platform->o_mempool.slice1.copyFrom(platform->mempool.slice1, mesh->Nlocal * sizeof(dfloat));
    ellipticOperator(pSolver, platform->o_mempool.slice1, platform->o_mempool.slice2, dfloatString);

    // RHS = b_0 + Ax (x is a random, continous vector obeying the BCs)
    platform->linAlg->axpbyz(
      mesh->Nlocal,
      1.0,
      platform->o_mempool.slice0,
      1.0,
      platform->o_mempool.slice2,
      platform->o_mempool.slice3
    );

    platform->timer.tic("pressureSolve", 1);
    ellipticSolve(nrs->pSolver, platform->o_mempool.slice3, nrs->o_P);
    platform->timer.toc("pressureSolve");

    iterations[i] = nrs->pSolver->Niter;
    
    if(platform->comm.mpiRank == 0) {
      printf(".");
      fflush(stdout); 
    }
  }
  if(platform->comm.mpiRank == 0) printf("\n"); 

  // compute average num iters
  double avgIters = 0.0;
  for(int i = 0; i < Nrep; ++i){
    avgIters += iterations[i];
  }
  avgIters /= Nrep;

  hlong Ntotal = mesh->Nelements * (mesh->N * mesh->N * mesh->N);
  MPI_Allreduce(MPI_IN_PLACE, &Ntotal, 1, MPI_HLONG, MPI_SUM, platform->comm.mpiComm);
  const double solveTime = platform->timer.query("pressureSolve", "DEVICE:MAX")/Nrep;
  const double precoTime = platform->timer.query("pressure preconditioner", "DEVICE:MAX")/Nrep;
  const double smootherTime = platform->timer.query("pressure preconditioner smoother", "DEVICE:MAX")/Nrep;
  const double crsTime = platform->timer.query("coarseSolve", "DEVICE:MAX")/Nrep;
  if(platform->comm.mpiRank == 0) {
    const double throughput = (double)Ntotal/solveTime;
    //printf("iterations: %d\n", nrs->pSolver->Niter);
    printf("avg iterations: %g\n", avgIters);
    printf("avg solve time: %g s\n", solveTime);
    printf("  preconditioner %g s\n", precoTime);
    if(smootherTime > 0) printf("    smoother %g s\n", smootherTime);
    if(crsTime > 0) printf("    coarse grid %g s\n", crsTime);
    printf("avg throughput: %g DOF/s\n", throughput);
    printf("avg throughput: %g (DOF x iter)/s\n", (double) nrs->pSolver->Niter * throughput);
  }
}
