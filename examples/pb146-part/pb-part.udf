//
// nekRS User Defined File
//

#include <math.h>
#include "udf.hpp"

#include "lpm/historyParticle.hpp"

#include "casedata.h"

/* Particle Functions */
void particleInit(historyParticles_t& particles) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;

  // n particle sources at different radius's
  constexpr dlong nSources = 3;
  constexpr dfloat sourceX[nSources] = {0.0, 0.0, 0.0};
  constexpr dfloat sourceY[nSources] = {0.0, 0.5*XY_RADIUS, XY_RADIUS};

  for (int source = 0; source < nSources; ++source) {

    dfloat xp = sourceX[source];
    dfloat yp = sourceY[source];
    dfloat zp = Z_MIN + 0.001;

    if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
      historyParticles_t::particle_t particle;

      particle.x[0] = xp;
      particle.x[1] = yp;
      particle.x[2] = zp;
      particle.extra.id = gcount;
      for (int d = 0; d < 3; ++d) {
        particle.extra.v_hist[0][d] = 0.0;
        particle.extra.v_hist[1][d] = 0.0;
      }
//    particle.extra.color = time;    // color by spawning timestep
//    particle.extra.color = gcount;  // color by id
//    particle.extra.color = xp;      // color by intial x position
      particle.extra.color = source;  // color by source

      particles.push(particle);
    }
    ++gcount; // Total count
  }
}


void applyBounds(historyParticles_t& particles) {

  for (int i = 0; i < particles.size(); ++i) {

    // remove particles at the outflow
    if (particles.x[2][i] > Z_MAX) {
      particles.remove(i);
      --i; // cancel out the for loop increment
    }
  }
}

historyParticles_t *particle_data;

/* UDF Functions */                                                      

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup(nrs_t *nrs)
{
  particle_data = new historyParticles_t(nrs, 0);
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  const bool ifInit = tstep % 100 == 0; // every 100 iterations

  if (ifInit) {
    particleInit(*particle_data);
  }

  particleUpdate(*particle_data, nrs, tstep);
  applyBounds(*particle_data);

  if (nrs->isOutputStep) {
    particleOut(*particle_data);
  }
}
