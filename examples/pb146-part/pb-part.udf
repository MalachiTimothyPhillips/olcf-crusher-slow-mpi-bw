//
// nekRS User Defined File
//

#include <math.h>
#include "udf.hpp"

#include "lpm/particle.hpp"

#include "casedata.h"

particles_t *particles;

/* Particle Functions */
void particleInit(particles_t& p) {

  static hlong gcount = 0; // total # particles emitted

  int mpi_rank = platform->comm.mpiRank;
  int mpi_size = platform->comm.mpiCommSize;

  // n particle sources at different radius's
  constexpr dlong nSources = 3;
  constexpr dfloat sourceX[nSources] = {0.0, 0.0, 0.0};
  constexpr dfloat sourceY[nSources] = {0.0, 0.5*XY_RADIUS, XY_RADIUS};

  for (int source = 0; source < nSources; ++source) {

    dfloat xp = sourceX[source];
    dfloat yp = sourceY[source];
    dfloat zp = Z_MIN + 0.001;

    if (gcount%mpi_size == mpi_rank) { // Distribute particles in a round robin fashion
      particle_t particle;

      particle.x[0] = xp;
      particle.x[1] = yp;
      particle.x[2] = zp;
      particle.extra.id = gcount;
      for (int d = 0; d < 3; ++d) {
        particle.extra.v_hist[0][d] = 0.0;
        particle.extra.v_hist[1][d] = 0.0;
      }
//    particle.extra.color = time;    // color by spawning timestep
//    particle.extra.color = gcount;  // color by id
//    particle.extra.color = xp;      // color by intial x position
      particle.extra.color = source;  // color by source

      p.push(particle);
    }
    ++gcount; // Total count
  }
}


void applyBounds(particles_t& p) {

  for (int i = 0; i < p.size(); ++i) {

    // remove particles at the outflow
    if (p.x[2][i] > Z_MAX) {
      p.remove(i);
      --i; // cancel out the for loop increment
    }
  }
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new particles_t(nrs, 0);
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  const bool ifInit = tstep % 100 == 0; // every 100 iterations

  if (ifInit) {
    particleInit(*particles);
  }

  particles->update(nrs->o_U, nrs->dt, tstep);
  applyBounds(*particles);

  if (nrs->isOutputStep) {
    particles->write();
  }
}